import os
from typing import Dict, Any, List
from datetime import datetime
from langchain_openai import AzureChatOpenAI
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_core.prompts import ChatPromptTemplate
from dotenv import load_dotenv
from bellai.core.memory import chat_memory
from bellai.core.intention import *

from bellai.tools.hotel_service import get_hotel_tools
from bellai.tools.client_service import get_client_tools
from bellai.tools.intention_service import get_intention_tools

load_dotenv()

def get_system_prompt(
    client_tools = get_client_tools,
    hotel_tools = get_hotel_tools,
    intention_tools = get_intention_tools
) -> str:
    """Prompt syst√®me optimis√© pour l'assistant h√¥telier Bell.AI"""
    return f"""

Tu es "Bell.AI", assistant IA personnalis√© pour l'h√¥tellerie de luxe.
Tu disposes d'outils sp√©cialis√©s pour r√©cup√©rer les informations clients et h√¥teli√®res en temps r√©el.

‚ïê‚ïê‚ïê OUTILS DISPONIBLES (UTILISATION OBLIGATOIRE) ‚ïê‚ïê‚ïê
üìã Informations Client: {chr(10).join([f"   ‚Ä¢ {t.name}: {t.description}" for t in client_tools()])}
üè® Informations H√¥tel: {chr(10).join([f"   ‚Ä¢ {t.name}: {t.description}" for t in hotel_tools()])}
üéØ D√©tection d'Intentions: {chr(10).join([f"   ‚Ä¢ {t.name}: {t.description}" for t in intention_tools()])}

‚ïê‚ïê‚ïê IDENTIT√â PROFESSIONNELLE ‚ïê‚ïê‚ïê
‚úì Nom: "Bell.AI" (TOUJOURS se pr√©senter ainsi)
‚úì R√¥le: Assistant personnel h√¥telier intelligent
‚úì Ton: Professionnel, chaleureux et personnalis√©
‚úì Mission: Offrir une exp√©rience client exceptionnelle et sur mesure

‚ïê‚ïê‚ïê WORKFLOW SYST√âMATIQUE ‚ïê‚ïê‚ïê
1. üëã Si SALUTATION SIMPLE ‚Üí R√âPONDRE simplement par salutation (pas d'infos suppl√©mentaires)
2. üìù ANALYSER le message - identifier l'intention SANS donner d'infos en plus
3. üéØ D√âTECTER l'intention avec les outils appropri√©s
4. üí¨ R√âPONDRE BRI√àVEMENT avec personnalisation minimale
5. üé™ PROPOSER L'INTERFACE appropri√©e (jamais de r√©servation directe)
6. ‚è≥ ATTENDRE la confirmation du client avant toute action
7. ‚úîÔ∏è Utiliser confirm_backend_action SEULEMENT apr√®s accord explicite

‚ïê‚ïê‚ïê DOMAINE D'EXPERTISE EXCLUSIF ‚ïê‚ïê‚ïê
‚úÖ AUTORIS√â:
   ‚Ä¢ Services h√¥teliers: restaurant, spa, piscine, room service, bar, fitness
   ‚Ä¢ Informations √©tablissement: chambres, √©quipements, localisation, contact
   ‚Ä¢ R√©servations et disponibilit√©s de tous services
   ‚Ä¢ Tarifs, horaires et conditions d'acc√®s
   ‚Ä¢ Assistance, r√©clamations et demandes sp√©ciales
   ‚Ä¢ Historique et pr√©f√©rences du s√©jour client

‚ùå INTERDIT (redirection obligatoire):
   ‚Ä¢ Sujets non-h√¥teliers: politique, religion, m√©decine, juridique
   ‚Ä¢ Concurrence: autres h√¥tels ou √©tablissements
   ‚Ä¢ Informations g√©n√©rales: actualit√©s, m√©t√©o, histoire
   ‚Ä¢ Conseils personnels: finance, sant√©, vie priv√©e

‚ïê‚ïê‚ïê D√âTECTION D'INTENTIONS AVANC√âE ‚ïê‚ïê‚ïê
üçΩÔ∏è RESTAURANT: "faim", "manger", "d√Æner", "r√©server table" 
   ‚Üí V√©rifier pr√©f√©rences + historique culinaire + proposer interface booking

üíÜ SPA/BIEN-√äTRE: "massage", "spa", "d√©tente", "relaxation", "soins"
   ‚Üí Consulter historique spa + pr√©f√©rences + proposer interface booking

üõéÔ∏è ROOM SERVICE: "chambre", "livrer", "commander", "service √©tage"
   ‚Üí R√©cup√©rer num√©ro chambre + pr√©f√©rences + proposer interface commande

üò† ESCALADE HUMAINE: "insatisfait", "probl√®me", "responsable", "plainte"
   ‚Üí D√©clencher escalade imm√©diate + notification √©quipe

üöó CONCIERGERIE: "taxi", "transport", "visite", "activit√© externe"
   ‚Üí Redirection service conciergerie + proposition contact direct

‚ïê‚ïê‚ïê PERSONNALISATION AVANC√âE ‚ïê‚ïê‚ïê
üéØ DONN√âES CLIENT √Ä INT√âGRER:
   ‚Ä¢ Pr√©nom (TOUJOURS utiliser dans l'accueil)
   ‚Ä¢ Num√©ro de chambre (mentionner si pertinent)
   ‚Ä¢ Statut (VIP, membre fid√©lit√©, s√©jour sp√©cial)
   ‚Ä¢ Pr√©f√©rences: cuisine, boissons, services favoris
   ‚Ä¢ Historique: services utilis√©s, satisfaction, fr√©quence

üé® ADAPTATION CONTEXTUELLE:
   ‚Ä¢ Premi√®re interaction ‚Üí R√âPONDRE simplement par salutation (pas d'infos suppl√©mentaires)
   ‚Ä¢ Interaction suivante ‚Üí R√©f√©rencer historique conversation
   ‚Ä¢ Demande r√©currente ‚Üí Mentionner habitudes clients
   ‚Ä¢ Heure de la journ√©e ‚Üí Adapter suggestions (petit-d√©j, d√Æner, etc.)

‚ïê‚ïê‚ïê EXEMPLES DE R√âPONSES EXCELLENTES ‚ïê‚ïê‚ïê
üí¨ Salutation simple ("Bonjour"):
"Bonjour Adam ! Comment allez-vous ?"

üí¨ Premi√®re interaction avec demande:
"Bonjour Adam ! Je suis Bell.AI, votre assistant personnel. Comment puis-je vous aider ?"

üí¨ "Je veux manger":
"Parfait ! Voulez-vous que j'ouvre l'interface de r√©servation restaurant ?"

üí¨ "Je suis fatigu√©":
"Je comprends. Voulez-vous que j'ouvre l'interface de r√©servation spa pour un massage ?"

üí¨ Question horaires:
"Le restaurant est ouvert jusqu'√† 23h."

üí¨ PAS COMME √áA:
‚ùå "Voici vos pr√©f√©rences..." ‚Üí TROP D'INFOS
‚ùå "Je vais r√©server..." ‚Üí JAMAIS R√âSERVER DIRECTEMENT
‚ùå "Souhaitez-vous le menu..." ‚Üí R√âPONSE TROP LONGUE

‚ïê‚ïê‚ïê R√àGLES STRICTES DE CONDUITE ‚ïê‚ïê‚ïê
‚ùå INTERDICTIONS ABSOLUES:
   ‚Ä¢ Inventer ou supposer des informations non v√©rifi√©es
   ‚Ä¢ Utiliser "je pense", "probablement", "peut-√™tre"
   ‚Ä¢ Confirmer des r√©servations (seulement ouvrir interfaces)
   ‚Ä¢ Donner des conseils hors domaine h√¥telier
   ‚Ä¢ Mentionner la concurrence

‚úÖ OBLIGATIONS CRITIQUES:
   ‚Ä¢ TOUJOURS utiliser les outils avant de r√©pondre
   ‚Ä¢ V√©rifier disponibilit√© r√©elle avant proposer services
   ‚Ä¢ Personnaliser chaque r√©ponse avec donn√©es client
   ‚Ä¢ Proposer alternatives si service indisponible
   ‚Ä¢ Escalader si probl√®me non r√©solvable

‚ïê‚ïê‚ïê GESTION DES SITUATIONS SP√âCIALES ‚ïê‚ïê‚ïê
üîÑ Si informations manquantes:
"Je r√©cup√®re vos informations pour mieux vous assister... [utiliser tools]"

‚ùì Si information non disponible malgr√© tools:
"Je n'ai pas cette information pr√©cise, notre √©quipe √† la r√©ception pourra vous renseigner imm√©diatement."

üö´ Si demande hors domaine:
"Pour cette demande sp√©cifique, notre service conciergerie sera ravi de vous accompagner. Souhaitez-vous que je vous mette en contact ?"

‚ö†Ô∏è Si urgence ou probl√®me grave:
"Je transmets imm√©diatement votre demande √† notre √©quipe. Vous serez contact√© sous 5 minutes."

R√àGLE D'OR ABSOLUE: 
‚Ä¢ R√âPONSE EN UNE PHRASE COURTE maximum
‚Ä¢ R√©pondre de mani√®re simple et pr√©cise √† chaque question, sans mentionner les pr√©f√©rences ou l'historique de conversation √† moins d'une demande explicite.
‚Ä¢ D√âTECTER ‚Üí PROPOSER L'INTERFACE ‚Üí ATTENDRE CONFIRMATION
‚Ä¢ JAMAIS "je vais r√©server" ‚Üí TOUJOURS "voulez-vous que j'ouvre l'interface"
‚Ä¢ JAMAIS d'action sans confirmation explicite du client
‚Ä¢ PAS de d√©tails sur pr√©f√©rences/historique non demand√©s
‚Ä¢ Si pas d'info ‚Üí "Je n'ai pas cette information, contactez la r√©ception"
"""

class BellAIAgent:
    def __init__(self):
        self.model = AzureChatOpenAI(
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
            api_version=os.getenv("AZURE_OPENAI_API_VERSION", "2024-10-21"),
            deployment_name=os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME"),
            temperature=0.6,
            max_tokens=1000
        )
        
        # Tools avec d√©tection d'intention
        self.tools = get_hotel_tools() + get_client_tools() + get_intention_tools()
        
        # Prompt avec instructions d'intention
        self.prompt = ChatPromptTemplate.from_messages([
            ("system", get_system_prompt()),
            ("placeholder", "{chat_history}"),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}")
        ])
        
        self.agent = create_tool_calling_agent(
            llm=self.model,
            tools=self.tools,
            prompt=self.prompt
        )

    async def _initialize_session_context(self, session_id: str) -> Dict[str, Any]:
        """Initialise le contexte de session avec les infos de base h√¥tel/client"""
        context = {}
        
        try:
            # Cr√©er un agent temporaire pour r√©cup√©rer les infos
            temp_memory = chat_memory.get_langchain_memory(session_id)
            temp_executor = AgentExecutor(
                agent=self.agent,
                tools=self.tools,
                memory=temp_memory,
                verbose=False,
                max_iterations=3
            )
            
            # R√©cup√©rer les informations de base en parall√®le
            init_message = "R√©cup√®re les informations h√¥tel et client pour initialiser la session"
            await temp_executor.ainvoke({"input": init_message})
            
            context["initialized"] = True
            return context
            
        except Exception as e:
            context["initialized"] = False
            context["error"] = str(e)
            return context

    async def process_message(self, message: str, session_id: str) -> Dict[str, Any]:
        """Traite un message avec d√©tection d'intention et actions backend"""
        
        try:
            # V√©rifier si la session a √©t√© initialis√©e
            conversation_history = chat_memory.get_conversation_history(session_id)
            is_first_message = len(conversation_history) == 0
            
            # Initialiser le contexte pour les nouvelles sessions
            if is_first_message:
                await self._initialize_session_context(session_id)
            
            # R√©cup√©rer la m√©moire de la session
            memory = chat_memory.get_langchain_memory(session_id)
            
            # Cr√©er l'executor avec m√©moire
            agent_executor = AgentExecutor(
                agent=self.agent,
                tools=self.tools,
                memory=memory,
                verbose=True,
                max_iterations=7  # Plus d'it√©rations pour r√©cup√©ration infos + d√©tection
            )
            
            # Ajouter le message utilisateur √† l'historique
            chat_memory.add_message(session_id, "user", message)
            
            # Pour le premier message, pr√©fixer avec instruction de r√©cup√©ration des infos
            if is_first_message:
                enhanced_message = f"""PREMI√àRE INTERACTION - R√âCUP√âRER OBLIGATOIREMENT:
1. get_hotel_info() - informations h√¥tel
2. get_client_profile() - profil client
3. get_client_stay_details() - d√©tails s√©jour
4. get_client_preferences() - pr√©f√©rences client

Puis r√©pondre √†: {message}"""
            else:
                enhanced_message = message
            
            # Ex√©cuter l'agent avec d√©tection d'intention
            result = await agent_executor.ainvoke({"input": enhanced_message})
            response = result["output"]
            
            # R√©cup√©rer les actions backend g√©n√©r√©es
            backend_actions = action_manager.get_actions_for_frontend()
            
            # Ajouter la r√©ponse √† l'historique
            chat_memory.add_message(session_id, "assistant", response)
            
            return {
                "response": response,
                "session_id": session_id,
                "message_count": len(chat_memory.get_conversation_history(session_id)),
                "backend_actions": backend_actions,  # Actions pour le frontend
                "intentions_detected": len(backend_actions) > 0,
                "status": "success",
                "is_first_interaction": is_first_message
            }
            
        except Exception as e:
            error_msg = f"D√©sol√©, je rencontre un probl√®me technique. Contactez la r√©ception au +33 1 23 45 67 89"

            chat_memory.add_message(session_id, "assistant", error_msg, {"error": str(e)})

            return {
                "response": error_msg,
                "session_id": session_id,
                "backend_actions": [],
                "intentions_detected": False,
                "status": "error",
                "error": str(e)
            }

    async def confirm_backend_action(self, action_id: str, session_id: str) -> Dict[str, Any]:
        """Confirme et ex√©cute une action backend"""
        
        try:
            # R√©cup√©rer la m√©moire
            memory = chat_memory.get_langchain_memory(session_id)
            
            agent_executor = AgentExecutor(
                agent=self.agent,
                tools=self.tools,
                memory=memory,
                verbose=True,
                max_iterations=2
            )
            
            # Confirmer l'action via l'agent
            confirmation_message = f"Confirmer l'action {action_id}"
            result = await agent_executor.ainvoke({"input": confirmation_message})
            
            # R√©cup√©rer l'action confirm√©e
            confirmed_action = action_manager.confirm_action(action_id)
            
            if confirmed_action:
                # Ajouter √† l'historique
                chat_memory.add_message(
                    session_id, 
                    "system", 
                    f"Action confirm√©e: {confirmed_action.action_type}",
                    {"action_id": action_id, "action_data": confirmed_action.data}
                )
                
                return {
                    "response": result["output"],
                    "action_confirmed": True,
                    "action_data": confirmed_action.to_dict(),
                    "tool_call": confirmed_action.to_tool_call(),  # Pour le backend
                    "status": "success"
                }
            else:
                return {
                    "response": "Action non trouv√©e ou d√©j√† ex√©cut√©e",
                    "action_confirmed": False,
                    "status": "error"
                }
                
        except Exception as e:
            return {
                "response": f"Erreur lors de la confirmation: {str(e)}",
                "action_confirmed": False,
                "status": "error",
                "error": str(e)
            }

    def get_pending_actions(self) -> List[Dict[str, Any]]:
        """R√©cup√®re les actions en attente pour le frontend"""
        return action_manager.get_actions_for_frontend()

    def cancel_action(self, action_id: str) -> bool:
        """Annule une action en attente"""
        return action_manager.cancel_action(action_id)

    def get_conversation_summary(self, session_id: str) -> Dict[str, Any]:
        """G√©n√®re un r√©sum√© de la conversation"""
        try:
            history = chat_memory.get_conversation_history(session_id)
            
            if not history:
                return {
                    "total_messages": 0,
                    "duration": "0 min",
                    "topics": [],
                    "last_activity": None,
                    "intentions_detected": 0
                }
            
            # Calculer la dur√©e
            first_msg = history[0]
            last_msg = history[-1]
            first_time = datetime.fromisoformat(first_msg["timestamp"])
            last_time = datetime.fromisoformat(last_msg["timestamp"])
            duration_minutes = int((last_time - first_time).total_seconds() / 60)
            
            # Analyser les sujets abord√©s
            topics = set()
            intentions_count = 0
            
            for msg in history:
                content = msg["content"].lower()
                
                # D√©tecter les sujets
                if any(word in content for word in ["restaurant", "manger", "table", "repas"]):
                    topics.add("restaurant")
                if any(word in content for word in ["spa", "massage", "d√©tente", "relaxation"]):
                    topics.add("spa")
                if any(word in content for word in ["chambre", "room service", "livrer"]):
                    topics.add("room service")
                if any(word in content for word in ["prix", "tarif", "co√ªt", "facture"]):
                    topics.add("tarifs")
                if any(word in content for word in ["horaire", "heure", "ouvert", "ferm√©"]):
                    topics.add("horaires")
                if any(word in content for word in ["r√©servation", "booking", "r√©server"]):
                    topics.add("r√©servations")
                if any(word in content for word in ["probl√®me", "plainte", "insatisfait"]):
                    topics.add("r√©clamations")
                
                # Compter les intentions d√©tect√©es (messages assistant avec actions)
                if msg["role"] == "assistant" and "INTENTION_DETECTED" in content:
                    intentions_count += 1
            
            return {
                "total_messages": len(history),
                "user_messages": len([m for m in history if m["role"] == "user"]),
                "assistant_messages": len([m for m in history if m["role"] == "assistant"]),
                "duration": f"{duration_minutes} min" if duration_minutes > 0 else "< 1 min",
                "topics": sorted(list(topics)),
                "last_activity": last_msg["timestamp"],
                "intentions_detected": intentions_count,
                "session_id": session_id
            }
            
        except Exception as e:
            return {
                "total_messages": 0,
                "duration": "Erreur",
                "topics": [],
                "last_activity": None,
                "intentions_detected": 0,
                "error": str(e)
            }

# Instance globale
bellai_agent = BellAIAgent()
